\subsection{Peters' Scheme for $C^1$ B{\'e}zier surface reconstruction}
Although the process of generating a NURBS surface may trivially only seem to consist of placing out the control points near the desired surface location, getting it to assume a specified shape can be quite a task. As generating a topology more complex than a torus \todointern{possible reference to figure above} also requires several NURBS surfaces joined together, one needs to filfill certain requirements in order for it to remain connected. For simple surface continuity ($C^0$), it is enough that the control points and knots on the edges of the two patches are the same as the surface then on both edges follows a 1D--NURBS-curve from these points and knots. As higher-order continuity desired for smooth surfaces creates much more complex requirements, several schemes have been created to automate such tasks.

The approach sometimes referred to as \emph{surface splines} or \emph{G-splines} \cite{eck1996automatic} solves the task of generating a smooth surface by starting from a \emph{control mesh} $\petersControlMesh$ of points, and compute B{\'e}zier surfaces by setting their control points to be linear combinations of the points in $\petersControlMesh$, with the coefficients determined such that the resulting surfaces will be \emph{tangent plane continous}, or $G^1$, or other desired degrees of smoothness. 

One such scheme is the scheme of Peters, described in \cite{peters1992constructing}, which starts from an unstructured mesh of polygonal faces, and creates from the location and connectivity of its vertices a $G^1$--continous surface. This means that the normal vector to the plane is countinous, resulting in a smooth surface without sharp corners. The process consists of two steps, described below for a mesh of quadrilateral faces (quads), however, the scheme can be applied for a mesh of any mixture of polygons.\tododone[inline]{mention that it's called surface splines or G-splines to create surface from a mesh}

\subsubsection{Mesh refinement}
In the first step, the mesh is refined through two applications of \emph{Doo-Sabin refinement}. In one step of this refinement, a new point $\vec{m}_{ref}$  is created for each vertex $\petersControlMeshVec$ in the control mesh $\petersControlMesh$, for every face $f_{\vec{m}}$ that $\petersControlMeshVec$ corners,  between $\petersControlMeshVec$ and the centroid $\centroidof{f_{\petersControlMeshVec}}$ (the average position of its vertices) of the bordering face $f_{\petersControlMeshVec}$. The refined mesh $\petersControlMesh^ref$ then consists of all these created points. Mathematically, for the faces $\petersFaces$, with face ${\hat{f}}$ having vertices $V_{\hat{f}}$:

\begin{align}
\petersControlMesh^{(ref)} =& \lbrace \petersControlMeshVec_{ref} \suchthat\petersControlMeshVec_{ref} = \alpha\petersControlMeshVec + (1-\alpha)\centroidof{f} \suchthat f \in \facesof{\petersControlMeshVec} \suchthat
\\ \notag &
 \suchthat \petersControlMeshVec \in \petersControlMesh, \alpha \in (0,1) \rbrace
\\
\where \qquad\qquad \centroidof{\hat{f}} =& \text{average}(\petersControlMeshVec_{\hat{f}})_{\petersControlMeshVec_{\hat{f}} \in \verticesof{\hat{f}}}
\\
\text{and} \qquad\qquad F_{\vec{\hat{m}}} =& \left\lbrace \hat{f} \suchthat \vec{\hat{m}} \in \verticesof{\hat{f}}	\right\rbrace
\end{align}

Thus, in every refinement step on an $n$--gon, $n$ vertices are created, giving 4 vertices for a quad in the original control mesh. These are then joined up with the neighbours on the quad to form a smaller quad, and with the neighbouring points from the same vertex on the neighbouring quads, forming a quad along each edge, and an $n$--gon around each original vertex, where $n$ is the number of quads that the original cornered. After two refinements, we thus get a mesh of vertices $\petersPatchPoints$ that consists mainly of quads, with some possible other-$n$--gons around the vertices of the original mesh $\petersControlMesh$. \todointern{maybe fancy peter's scheme picture, alt the one in EckHoppe for what the thingymajong looks like after 2x ref.}

\subsubsection{Bezier patch creation}
In this step, we create one B{\'e}zier patch for every vertex in the double refined mesh $\petersControlMesh$. 


\todointern[inline]{insert stuff here}
In this section we will cover the following, referring to \cite{peters1992constructing}:
\begin{itemize}
\item How we go from polygonal faces to a set of mesh control points. "patch points", specifying that we're talking about quads, and that we then get 16
\item That for each of these 16 points, we will make a small B{\'e}zier patch
\item That if we define the B{\'e}zier control points of these patches in a special way, as described in appendix XYZ \todointern{TODO: create this appendix, or change this to refer to paper for coefficients}, we get a surface that is $G^1$ continous
\item Maybe describe that we then need for every one of these B{\'e}zier patches the locations of the neighbours
\item That the location of a point on the surface defined by parameters $\vec{s} = (u,v)$ depends on the B{\'e}zier control points, whose linear dependence on the "patch points" give us coefficients on these "patch points" of the location described by the parameters, as can be seen in \autoref{fig:PetersPoints}
\item Possibly that this can used to fit the location of these "patch points" to a set of datapoints by minimusing a least-squares error \todointern{stress the relation to parametrized datapoints}
\end{itemize}
\begin{figure}

\missingfigure{Graphical description of all those different points in Peters' Scheme}
\label{fig:PetersPoints}
\caption{The points in Peters' Scheme. As clearly seen in the figure above, this scheme is self-explanatory.}
\end{figure}